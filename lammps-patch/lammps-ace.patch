diff -Naur lammps-ace-org/src/MANYBODY/pair_eam.cpp lammps-ace/src/MANYBODY/pair_eam.cpp
--- lammps-ace-org/src/MANYBODY/pair_eam.cpp	2021-01-05 14:41:27.660000000 +0100
+++ lammps-ace/src/MANYBODY/pair_eam.cpp	2021-01-05 13:46:44.540000000 +0100
@@ -239,7 +239,8 @@
     if (eflag) {
       phi = ((coeff[3]*p + coeff[4])*p + coeff[5])*p + coeff[6];
       if (rho[i] > rhomax) phi += fp[i] * (rho[i]-rhomax);
-      phi *= scale[type[i]][type[i]];
+      //remove energy scaling
+      //phi *= scale[type[i]][type[i]];
       if (eflag_global) eng_vdwl += phi;
       if (eflag_atom) eatom[i] += phi;
     }
@@ -317,7 +318,8 @@
           f[j][2] -= delz*fpair;
         }
 
-        if (eflag) evdwl = scale[itype][jtype]*phi;
+        //if (eflag) evdwl = scale[itype][jtype]*phi;
+        if (eflag) evdwl = phi;
         if (evflag) ev_tally(i,j,nlocal,newton_pair,
                              evdwl,0.0,fpair,delx,dely,delz);
       }
diff -Naur lammps-ace-org/src/MANYBODY/pair_sw.cpp lammps-ace/src/MANYBODY/pair_sw.cpp
--- lammps-ace-org/src/MANYBODY/pair_sw.cpp	2021-01-05 14:41:27.660000000 +0100
+++ lammps-ace/src/MANYBODY/pair_sw.cpp	2021-01-05 13:46:44.540000000 +0100
@@ -72,6 +72,7 @@
     memory->destroy(setflag);
     memory->destroy(cutsq);
     memory->destroy(neighshort);
+    memory->destroy(scale);
     delete [] map;
   }
 }
@@ -156,6 +157,7 @@
 
       twobody(&params[ijparam],rsq,fpair,eflag,evdwl);
 
+      fpair *= scale[1][1];
       fxtmp += delx*fpair;
       fytmp += dely*fpair;
       fztmp += delz*fpair;
@@ -194,6 +196,13 @@
 
         threebody(&params[ijparam],&params[ikparam],&params[ijkparam],
                   rsq1,rsq2,delr1,delr2,fj,fk,eflag,evdwl);
+        
+        fj[0] *= scale[1][1];
+        fj[1] *= scale[1][1];
+        fj[2] *= scale[1][1];
+        fk[0] *= scale[1][1];
+        fk[1] *= scale[1][1];
+        fk[2] *= scale[1][1];
 
         fxtmp -= fj[0] + fk[0];
         fytmp -= fj[1] + fk[1];
@@ -229,6 +238,7 @@
   memory->create(setflag,n+1,n+1,"pair:setflag");
   memory->create(cutsq,n+1,n+1,"pair:cutsq");
   memory->create(neighshort,maxshort,"pair:neighshort");
+  memory->create(scale,n+1,n+1,"pair:scale");
   map = new int[n+1];
 }
 
@@ -306,6 +316,7 @@
   for (int i = 1; i <= n; i++)
     for (int j = i; j <= n; j++)
       if (map[i] >= 0 && map[j] >= 0) {
+        scale[i][j] = 1.0;
         setflag[i][j] = 1;
         count++;
       }
@@ -338,7 +349,7 @@
 double PairSW::init_one(int i, int j)
 {
   if (setflag[i][j] == 0) error->all(FLERR,"All pair coeffs are not set");
-
+  scale[j][i] = scale[i][j];
   return cutmax;
 }
 
@@ -622,3 +633,10 @@
 
   if (eflag) eng = facrad;
 }
+
+void *PairSW::extract(const char *str, int &dim)
+{
+    dim = 2;
+    if (strcmp(str,"scale") == 0) return (void *) scale;
+    return NULL;
+}
\ No newline at end of file
diff -Naur lammps-ace-org/src/MANYBODY/pair_sw.h lammps-ace/src/MANYBODY/pair_sw.h
--- lammps-ace-org/src/MANYBODY/pair_sw.h	2021-01-05 14:41:27.660000000 +0100
+++ lammps-ace/src/MANYBODY/pair_sw.h	2021-01-05 13:46:44.540000000 +0100
@@ -33,6 +33,8 @@
   virtual void coeff(int, char **);
   virtual double init_one(int, int);
   virtual void init_style();
+  void swap_eam(double *, double **);
+  virtual void *extract(const char *, int &);
 
   struct Param {
     double epsilon,sigma;
@@ -57,6 +59,7 @@
   Param *params;                // parameter set for an I-J-K interaction
   int maxshort;                 // size of short neighbor list array
   int *neighshort;              // short neighbor list array
+  double **scale;
 
   virtual void allocate();
   void read_file(char *);
diff -Naur lammps-ace-org/src/SNAP/pair_snap.cpp lammps-ace/src/SNAP/pair_snap.cpp
--- lammps-ace-org/src/SNAP/pair_snap.cpp	2021-01-05 14:41:27.680000000 +0100
+++ lammps-ace/src/SNAP/pair_snap.cpp	2021-01-05 13:46:44.540000000 +0100
@@ -50,6 +50,7 @@
   beta = NULL;
   bispectrum = NULL;
   snaptr = NULL;
+  scale = NULL;
 }
 
 /* ---------------------------------------------------------------------- */
@@ -76,6 +77,7 @@
     memory->destroy(setflag);
     memory->destroy(cutsq);
     memory->destroy(map);
+    memory->destroy(scale);
   }
 
 }
@@ -177,12 +179,12 @@
 
       snaptr->compute_deidrj(fij);
 
-      f[i][0] += fij[0];
-      f[i][1] += fij[1];
-      f[i][2] += fij[2];
-      f[j][0] -= fij[0];
-      f[j][1] -= fij[1];
-      f[j][2] -= fij[2];
+      f[i][0] += scale[itype][jtype]*fij[0];
+      f[i][1] += scale[itype][jtype]*fij[1];
+      f[i][2] += scale[itype][jtype]*fij[2];
+      f[j][0] -= scale[itype][jtype]*fij[0];
+      f[j][1] -= scale[itype][jtype]*fij[1];
+      f[j][2] -= scale[itype][jtype]*fij[2];
 
       // tally per-atom virial contribution
 
@@ -344,6 +346,7 @@
   memory->create(setflag,n+1,n+1,"pair:setflag");
   memory->create(cutsq,n+1,n+1,"pair:cutsq");
   memory->create(map,n+1,"pair:map");
+  memory->create(scale,n+1,n+1,"pair:scale");
 }
 
 /* ----------------------------------------------------------------------
@@ -436,9 +439,11 @@
     for (int j = i; j <= n; j++)
       if (map[i] >= 0 && map[j] >= 0) {
         setflag[i][j] = 1;
+        scale[i][j] = 1.0;
         count++;
       }
 
+
   if (count == 0) error->all(FLERR,"Incorrect args for pair coefficients");
 
   snaptr = new SNA(lmp,rfac0,twojmax,
@@ -484,6 +489,7 @@
 double PairSNAP::init_one(int i, int j)
 {
   if (setflag[i][j] == 0) error->all(FLERR,"All pair coeffs are not set");
+  scale[j][i] = scale[i][j];
   return (radelem[map[i]] +
           radelem[map[j]])*rcutfac;
 }
@@ -727,3 +733,9 @@
   return bytes;
 }
 
+void *PairSNAP::extract(const char *str, int &dim)
+{
+  dim = 2;
+  if (strcmp(str,"scale") == 0) return (void *) scale;
+  return NULL;
+}
diff -Naur lammps-ace-org/src/SNAP/pair_snap.h lammps-ace/src/SNAP/pair_snap.h
--- lammps-ace-org/src/SNAP/pair_snap.h	2021-01-05 14:41:27.680000000 +0100
+++ lammps-ace/src/SNAP/pair_snap.h	2021-01-05 13:46:44.540000000 +0100
@@ -34,6 +34,7 @@
   virtual void init_style();
   virtual double init_one(int, int);
   virtual double memory_usage();
+  virtual void *extract(const char *, int &);
 
   double rcutfac, quadraticflag; // declared public to workaround gcc 4.9
   int ncoeff;                    //  compiler bug, manifest in KOKKOS package
@@ -62,6 +63,7 @@
   double rfac0, rmin0, wj1, wj2;
   int rcutfacflag, twojmaxflag; // flags for required parameters
   int beta_max;                 // length of beta
+  double **scale;
 };
 
 }
diff -Naur lammps-ace-org/src/USER-MISC/pair_list.cpp lammps-ace/src/USER-MISC/pair_list.cpp
--- lammps-ace-org/src/USER-MISC/pair_list.cpp	2021-01-05 14:41:27.740000000 +0100
+++ lammps-ace/src/USER-MISC/pair_list.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,417 +0,0 @@
-/* ----------------------------------------------------------------------
-   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
-   http://lammps.sandia.gov, Sandia National Laboratories
-   Steve Plimpton, sjplimp@sandia.gov
-
-   Copyright (2003) Sandia Corporation.  Under the terms of Contract
-   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
-   certain rights in this software.  This software is distributed under
-   the GNU General Public License.
-
-   See the README file in the top-level LAMMPS directory.
-------------------------------------------------------------------------- */
-
-/* ----------------------------------------------------------------------
-   Contributing author: Axel Kohlmeyer (Temple U)
-------------------------------------------------------------------------- */
-
-#include "pair_list.h"
-#include <mpi.h>
-#include <cstring>
-#include <cmath>
-#include "atom.h"
-#include "comm.h"
-#include "force.h"
-#include "memory.h"
-#include "error.h"
-
-using namespace LAMMPS_NS;
-
-static const char * const stylename[] = {
-  "none", "harmonic", "morse", "lj126", NULL
-};
-
-// fast power function for integer exponent > 0
-static double mypow(double x, int n) {
-  double yy;
-
-  if (x == 0.0) return 0.0;
-
-  for (yy = 1.0; n != 0; n >>= 1, x *=x)
-    if (n & 1) yy *= x;
-
-  return yy;
-}
-
-typedef struct { double x,y,z; } dbl3_t;
-
-/* ---------------------------------------------------------------------- */
-
-PairList::PairList(LAMMPS *lmp) : Pair(lmp)
-{
-  single_enable = 0;
-  restartinfo = 0;
-  respa_enable = 0;
-  cut_global = 0.0;
-  style = NULL;
-  params = NULL;
-  check_flag = 1;
-}
-
-/* ---------------------------------------------------------------------- */
-
-PairList::~PairList()
-{
-  memory->destroy(setflag);
-  memory->destroy(cutsq);
-  memory->destroy(style);
-  memory->destroy(params);
-}
-
-/* ----------------------------------------------------------------------
-   in this pair style we don't use a neighbor list, but loop through
-   a list of pairwise interactions, determines the corresponding local
-   atom indices and compute those forces.
-------------------------------------------------------------------------- */
-
-void PairList::compute(int eflag, int vflag)
-{
-  ev_init(eflag,vflag);
-
-  const int nlocal = atom->nlocal;
-  const int newton_pair = force->newton_pair;
-  const dbl3_t * _noalias const x = (dbl3_t *) atom->x[0];
-  dbl3_t * _noalias const f = (dbl3_t *) atom->f[0];
-
-  double fpair,epair;
-  int i,j;
-
-  int pc = 0;
-  for (int n=0; n < npairs; ++n) {
-    const list_parm_t &par = params[n];
-    i = atom->map(par.id1);
-    j = atom->map(par.id2);
-
-    // if one of the two atoms is missing on the node skip
-    if ((i < 0) || (j < 0)) continue;
-
-    // both atoms are ghosts -> skip
-    if ((i >= nlocal) && (j >= nlocal)) continue;
-
-    // with newton pair and one ghost we have to skip half the cases.
-    // if id1 is a ghost, we skip if the sum of both ids is even.
-    // if id2 is a ghost, we skip if the sum of both ids is odd.
-    if (newton_pair) {
-      if ((i >= nlocal) && ((par.id1+par.id2) & 1) == 0) continue;
-      if ((j >= nlocal) && ((par.id1+par.id2) & 1) == 1) continue;
-    }
-
-    const double dx = x[i].x - x[j].x;
-    const double dy = x[i].y - x[j].y;
-    const double dz = x[i].z - x[j].z;
-    const double rsq = dx*dx + dy*dy + dz*dz;
-
-    fpair = epair = 0.0;
-    if (check_flag) {
-      if (newton_pair || i < nlocal) ++pc;
-      if (newton_pair || j < nlocal) ++pc;
-    }
-
-    if (rsq < par.cutsq) {
-      const double r2inv = 1.0/rsq;
-
-      if (style[n] == HARM) {
-        const double r = sqrt(rsq);
-        const double dr = par.parm.harm.r0 - r;
-        fpair = 2.0*par.parm.harm.k*dr/r;
-
-        if (eflag_either)
-          epair = par.parm.harm.k*dr*dr - par.offset;
-
-      } else if (style[n] == MORSE) {
-
-        const double r = sqrt(rsq);
-        const double dr = par.parm.morse.r0 - r;
-        const double dexp = exp(par.parm.morse.alpha * dr);
-        fpair = 2.0*par.parm.morse.d0*par.parm.morse.alpha
-          * (dexp*dexp - dexp) / r;
-
-        if (eflag_either)
-          epair = par.parm.morse.d0 * (dexp*dexp - 2.0*dexp) - par.offset;
-
-      } else if (style[n] == LJ126) {
-
-        const double r6inv = r2inv*r2inv*r2inv;
-        const double sig6  = mypow(par.parm.lj126.sigma,6);
-        fpair =  24.0*par.parm.lj126.epsilon*r6inv
-          * (2.0*sig6*sig6*r6inv - sig6) * r2inv;
-
-        if (eflag_either)
-          epair = 4.0*par.parm.lj126.epsilon*r6inv
-            * (sig6*sig6*r6inv - sig6) - par.offset;
-      }
-
-      if (newton_pair || i < nlocal) {
-        f[i].x += dx*fpair;
-        f[i].y += dy*fpair;
-        f[i].z += dz*fpair;
-      }
-
-      if (newton_pair || j < nlocal) {
-        f[j].x -= dx*fpair;
-        f[j].y -= dy*fpair;
-        f[j].z -= dz*fpair;
-      }
-
-      if (evflag) ev_tally(i,j,nlocal,newton_pair,epair,0.0,fpair,dx,dy,dz);
-    }
-  }
-  if (vflag_fdotr) virial_fdotr_compute();
-
-  if (check_flag) {
-    int tmp;
-    MPI_Allreduce(&pc,&tmp,1,MPI_INT,MPI_SUM,world);
-    if (tmp != 2*npairs)
-      error->all(FLERR,"Not all pairs processed in pair_style list");
-  }
-}
-
-/* ----------------------------------------------------------------------
-   allocate all arrays
-------------------------------------------------------------------------- */
-
-void PairList::allocate()
-{
-  allocated = 1;
-  int n = atom->ntypes;
-
-  memory->create(setflag,n+1,n+1,"pair:setflag");
-  for (int i = 1; i <= n; i++)
-    for (int j = i; j <= n; j++)
-      setflag[i][j] = 0;
-
-  memory->create(cutsq,n+1,n+1,"pair:cutsq");
-}
-
-/* ----------------------------------------------------------------------
-   create one pair style for each arg in list
-------------------------------------------------------------------------- */
-
-void PairList::settings(int narg, char **arg)
-{
-  if (narg < 2)
-    error->all(FLERR,"Illegal pair_style command");
-
-  cut_global = force->numeric(FLERR,arg[1]);
-  if (narg > 2) {
-    if (strcmp(arg[2],"nocheck") == 0) check_flag = 0;
-    if (strcmp(arg[2],"check") == 0) check_flag = 1;
-  }
-
-  FILE *fp = force->open_potential(arg[0]);
-  char line[1024];
-  if (fp == NULL)
-    error->all(FLERR,"Cannot open pair list file");
-
-  // count lines in file for upper limit of storage needed
-  int num = 1;
-  while(fgets(line,1024,fp)) ++num;
-  rewind(fp);
-  memory->create(style,num,"pair_list:style");
-  memory->create(params,num,"pair_list:params");
-
-  // now read and parse pair list file for real
-  npairs = 0;
-  char *ptr;
-  tagint id1, id2;
-  int nharm=0, nmorse=0, nlj126=0;
-
-  while(fgets(line,1024,fp)) {
-    ptr = strtok(line," \t\n\r\f");
-
-    // skip empty lines
-    if (!ptr) continue;
-
-    // skip comment lines starting with #
-    if (*ptr == '#') continue;
-
-    // get atom ids of pair
-    id1 = ATOTAGINT(ptr);
-    ptr = strtok(NULL," \t\n\r\f");
-    if (!ptr)
-      error->all(FLERR,"Incorrectly formatted pair list file");
-    id2 = ATOTAGINT(ptr);
-
-    // get potential type
-    ptr = strtok(NULL," \t\n\r\f");
-    if (!ptr)
-      error->all(FLERR,"Incorrectly formatted pair list file");
-
-    style[npairs] = NONE;
-    list_parm_t &par = params[npairs];
-    par.id1 = id1;
-    par.id2 = id2;
-
-    // harmonic potential
-    if (strcmp(ptr,stylename[HARM]) == 0) {
-      style[npairs] = HARM;
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if ((ptr == NULL) || (*ptr == '#'))
-        error->all(FLERR,"Incorrectly formatted harmonic pair parameters");
-      par.parm.harm.k = force->numeric(FLERR,ptr);
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if ((ptr == NULL) || (*ptr == '#'))
-        error->all(FLERR,"Incorrectly formatted harmonic pair parameters");
-      par.parm.harm.r0 = force->numeric(FLERR,ptr);
-
-      ++nharm;
-
-      // morse potential
-    } else if (strcmp(ptr,stylename[MORSE]) == 0) {
-      style[npairs] = MORSE;
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if (!ptr)
-        error->all(FLERR,"Incorrectly formatted morse pair parameters");
-      par.parm.morse.d0 = force->numeric(FLERR,ptr);
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if (!ptr)
-        error->all(FLERR,"Incorrectly formatted morse pair parameters");
-      par.parm.morse.alpha = force->numeric(FLERR,ptr);
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if (!ptr)
-        error->all(FLERR,"Incorrectly formatted morse pair parameters");
-      par.parm.morse.r0 = force->numeric(FLERR,ptr);
-
-      ++nmorse;
-
-    } else if (strcmp(ptr,stylename[LJ126]) == 0) {
-      // 12-6 lj potential
-      style[npairs] = LJ126;
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if (!ptr)
-        error->all(FLERR,"Incorrectly formatted 12-6 LJ pair parameters");
-      par.parm.lj126.epsilon = force->numeric(FLERR,ptr);
-
-      ptr = strtok(NULL," \t\n\r\f");
-      if (!ptr)
-        error->all(FLERR,"Incorrectly formatted 12-6 LJ pair parameters");
-      par.parm.lj126.sigma = force->numeric(FLERR,ptr);
-
-      ++nlj126;
-
-    } else {
-      error->all(FLERR,"Unknown pair list potential style");
-    }
-
-    // optional cutoff parameter. if not specified use global value
-    ptr = strtok(NULL," \t\n\r\f");
-    if ((ptr != NULL) && (*ptr != '#')) {
-      double cut = force->numeric(FLERR,ptr);
-      par.cutsq = cut*cut;
-    } else {
-      par.cutsq = cut_global*cut_global;
-    }
-
-    // count complete entry
-    ++npairs;
-  }
-  fclose(fp);
-
-  // informative output
-  if (comm->me == 0) {
-    if (screen)
-      fprintf(screen,"Read %d (%d/%d/%d) interacting pairs from %s\n",
-              npairs, nharm, nmorse, nlj126, arg[0]);
-    if (logfile)
-      fprintf(logfile,"Read %d (%d/%d/%d) interacting pairs from %s\n",
-              npairs, nharm, nmorse, nlj126, arg[0]);
-  }
-}
-
-/* ----------------------------------------------------------------------
-   there are no coeffs to be set, but we need to update setflag and pretend
-------------------------------------------------------------------------- */
-
-void PairList::coeff(int narg, char **arg)
-{
-  if (narg < 2) error->all(FLERR,"Incorrect args for pair coefficients");
-  if (!allocated) allocate();
-
-  int ilo,ihi,jlo,jhi;
-  force->bounds(FLERR,arg[0],atom->ntypes,ilo,ihi);
-  force->bounds(FLERR,arg[1],atom->ntypes,jlo,jhi);
-
-  int count = 0;
-  for (int i = ilo; i <= ihi; i++) {
-    for (int j = MAX(jlo,i); j <= jhi; j++) {
-      setflag[i][j] = 1;
-      count++;
-    }
-  }
-
-  if (count == 0) error->all(FLERR,"Incorrect args for pair coefficients");
-}
-
-/* ----------------------------------------------------------------------
-   init specific to this pair style: compute energy offset at cutoff
-------------------------------------------------------------------------- */
-
-void PairList::init_style()
-{
-  if (atom->tag_enable == 0)
-    error->all(FLERR,"Pair style list requires atom IDs");
-
-  if (atom->map_style == 0)
-    error->all(FLERR,"Pair style list requires an atom map");
-
-  if (offset_flag) {
-    for (int n=0; n < npairs; ++n) {
-      list_parm_t &par = params[n];
-
-      if (style[n] == HARM) {
-        const double dr = sqrt(par.cutsq) - par.parm.harm.r0;
-        par.offset = par.parm.harm.k*dr*dr;
-
-      } else if (style[n] == MORSE) {
-        const double dr = par.parm.morse.r0 - sqrt(par.cutsq);
-        const double dexp = exp(par.parm.morse.alpha * dr);
-        par.offset = par.parm.morse.d0 * (dexp*dexp - 2.0*dexp);
-
-      } else if (style[n] == LJ126) {
-        const double r6inv = par.cutsq*par.cutsq*par.cutsq;
-        const double sig6  = mypow(par.parm.lj126.sigma,6);
-        par.offset = 4.0*par.parm.lj126.epsilon*r6inv * (sig6*sig6*r6inv - sig6);
-      }
-    }
-  }
-}
-
-/* ----------------------------------------------------------------------
-   init for one type pair i,j and corresponding j,i
-   since we don't use atom types or neighbor lists, this is a NOP.
-------------------------------------------------------------------------- */
-
-double PairList::init_one(int, int)
-{
-  return cut_global;
-}
-
-/* ----------------------------------------------------------------------
-   memory usage of each sub-style
-------------------------------------------------------------------------- */
-
-double PairList::memory_usage()
-{
-  double bytes = npairs * sizeof(int);
-  bytes += npairs * sizeof(list_parm_t);
-  const int n = atom->ntypes+1;
-  bytes += n*(n*sizeof(int) + sizeof(int *));
-  bytes += n*(n*sizeof(double) + sizeof(double *));
-  return bytes;
-}
diff -Naur lammps-ace-org/src/USER-MISC/pair_list.h lammps-ace/src/USER-MISC/pair_list.h
--- lammps-ace-org/src/USER-MISC/pair_list.h	2021-01-05 14:41:27.740000000 +0100
+++ lammps-ace/src/USER-MISC/pair_list.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,116 +0,0 @@
-/* -*- c++ -*- ----------------------------------------------------------
-   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
-   http://lammps.sandia.gov, Sandia National Laboratories
-   Steve Plimpton, sjplimp@sandia.gov
-
-   Copyright (2003) Sandia Corporation.  Under the terms of Contract
-   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
-   certain rights in this software.  This software is distributed under
-   the GNU General Public License.
-
-   See the README file in the top-level LAMMPS directory.
-------------------------------------------------------------------------- */
-
-#ifdef PAIR_CLASS
-
-PairStyle(list,PairList)
-
-#else
-
-#ifndef LMP_PAIR_LIST_H
-#define LMP_PAIR_LIST_H
-
-#include "pair.h"
-
-namespace LAMMPS_NS {
-
-class PairList : public Pair {
- public:
-  PairList(class LAMMPS *);
-  virtual ~PairList();
-
-  virtual void compute(int, int);
-  virtual void settings(int, char **);
-  virtual void coeff(int, char **);
-  virtual void init_style();
-  virtual double init_one(int, int);
-  virtual double memory_usage();
-
- protected:
-  void allocate();
-
-  enum { NONE=0, HARM, MORSE, LJ126 };
-
-  // potential specific parameters
-  struct harm_p  { double k, r0;          };
-  struct morse_p { double d0, alpha, r0;  };
-  struct lj126_p { double epsilon, sigma; };
-
-  union parm_u {
-    struct harm_p harm;
-    struct morse_p morse;
-    struct lj126_p lj126;
-  };
-
-  typedef struct {
-    tagint id1,id2;        // global atom ids
-    double cutsq;       // cutoff**2 for this pair
-    double offset;      // energy offset
-    union parm_u parm;  // parameters for style
-  } list_parm_t;
-
- protected:
-  double cut_global;    // global cutoff distance
-  int *style;           // list of styles for pair interactions
-  list_parm_t *params;  // lisf of pair interaction parameters
-  int npairs;           // # of atom pairs in global list
-  int check_flag;       // 1 if checking for missing pairs
-};
-
-}
-
-#endif
-#endif
-
-/* ERROR/WARNING messages:
-
-E: Not all pairs processed in pair_style list
-
-Not all interacting pairs for which coefficients were found. This can be intentional
-and then you need to set the 'nocheck' option. If not, it usually means that the
-communication cutoff is too small. This can be ameliorated by either increasing
-the cutoff in the pair_style command or the communication cutoff.
-
-E: Illegal ... command
-
-Self-explanatory.  Check the input script syntax and compare to the
-documentation for the command.  You can use -echo screen as a
-command-line option when running LAMMPS to see the offending line.
-
-E: Cannot open pair list file
-
-Self-explanatory.  The file with the list of pairs cannot be open for reading.
-Check the path and permissions.
-
-E: Incorrectly formatted ...
-
-Self-explanatory.  The content of the pair list file does not match the documented
-format. Please re-read the documentation and carefully compare it to your file.
-
-E: Unknown pair list potential style
-
-Self-explanatory.  You requested a potential type that is not yet implemented or have a typo.
-
-E: Incorrect args for pair coefficients
-
-Self-explanatory.  Check the input script or data file.
-
-E: Pair style list requires atom IDs
-
-Self-explanatory.  The pairs in the list are identified via atom IDs, so they need to be present.
-
-E: Pair style list requires an atom map
-
-Self-explanatory.  Atoms are looked up via an atom map. Create one using the atom_style map command.
-
-*/
diff -Naur lammps-ace-org/src/USER-PACE/pair_pace.cpp lammps-ace/src/USER-PACE/pair_pace.cpp
--- lammps-ace-org/src/USER-PACE/pair_pace.cpp	2021-01-05 14:41:27.770000000 +0100
+++ lammps-ace/src/USER-PACE/pair_pace.cpp	2021-01-05 13:46:44.540000000 +0100
@@ -209,7 +209,7 @@
         // tally energy contribution
         if (eflag) {
             // evdwl = energy of atom I
-            evdwl = scale[1][1]*ace->e_atom;
+            evdwl = ace->e_atom;
             ev_tally_full(i, 2.0 * evdwl, 0.0, 0.0, 0.0, 0.0, 0.0);
         }
     }
